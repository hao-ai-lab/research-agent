"""MemoryView -- scoped interface to MemoryStore for a single agent.

Each agent gets a MemoryView on spawn. It auto-fills scope fields
(project, session, sweep, run, role, agent_id) on every write,
so agents never need to specify their own identity when writing.

See agentsys.md section 2.2 for the full spec.
"""

from __future__ import annotations

from typing import Any

from agentsys.types import Entry, EntryType


class MemoryView:
    """Scoped interface to a store (MemoryStore or FileStore) for a single agent.

    Provides convenience methods for writing entries, sending messages,
    reading inbox, and assembling prompt context. All writes are
    automatically tagged with the agent's scope fields.

    Attributes:
        agent_id: The owning agent's unique identifier.
        scope:    Dict with keys {project, session, sweep, run, role}.
        store:    The backing store instance (duck-typed: write/query/delete).
    """

    def __init__(
        self,
        agent_id: str,
        scope: dict,
        store: Any,
    ) -> None:
        self.agent_id = agent_id
        self.scope = scope
        self.store = store

    # ------------------------------------------------------------------
    # Write
    # ------------------------------------------------------------------

    def write(
        self,
        data: dict,
        type: EntryType,
        tags: list[str] | None = None,
        target_id: str | None = None,
    ) -> str:
        """Write an entry with scope fields auto-filled.

        Args:
            data:      The payload dict.
            type:      Entry type (METRICS, ALERT, RESULT, etc.).
            tags:      Optional tags for cross-cutting queries.
            target_id: Recipient agent id (for MESSAGE entries).

        Returns:
            The auto-generated entry key.
        """
        entry = Entry(
            key="",            # auto-generated by store.write()
            agent_id=self.agent_id,
            target_id=target_id,
            type=type,
            project=self.scope["project"],
            session=self.scope.get("session"),
            sweep=self.scope.get("sweep"),
            run=self.scope.get("run"),
            role=self.scope["role"],
            tags=tags or [],
            data=data,
            created_at=0.0,    # auto-set by store.write()
        )
        return self.store.write(entry)

    # ------------------------------------------------------------------
    # Read helpers
    # ------------------------------------------------------------------

    def read_self(self) -> list[Entry]:
        """Return all entries produced by this agent."""
        return self.store.query(agent_id=self.agent_id)

    # ------------------------------------------------------------------
    # Context assembly
    # ------------------------------------------------------------------

    def assemble_context(self, token_budget: int) -> str:
        """Build prompt context string from the store.

        Strategy (see agentsys.md section 2.2):
          1. Own entries (type_not=RAW_FILE) -- most relevant.
          2. Widen by scope: for each level (run -> sweep -> session ->
             project), include latest CONTEXT + REFLECTION + recent ALERTs.
          3. Format as text, truncate to token_budget.

        Token approximation: 1 token ~ 4 chars (good enough for sandbox).

        Returns:
            Formatted context string within the token budget.
        """
        char_budget = token_budget * 4
        sections: list[str] = []
        seen_keys: set[str] = set()  # track included entries to avoid duplicates

        # --- Step 1: Own entries (skip RAW_FILE) ---
        own = self.store.query(
            agent_id=self.agent_id,
            type_not=EntryType.RAW_FILE,
            order="asc",
        )
        if own:
            seen_keys.update(e.key for e in own)
            lines = [_format_entry(e) for e in own]
            sections.append("## My Entries\n" + "\n".join(lines))

        # --- Step 2: Widen by scope ---
        # Query progressively broader scopes for CONTEXT, REFLECTION, ALERT.
        # Deduplicate: skip entries already included in earlier sections.
        widen_types = [EntryType.CONTEXT, EntryType.REFLECTION, EntryType.ALERT]
        scope_levels = _build_scope_levels(self.scope)

        for label, filters in scope_levels:
            entries = self.store.query(
                type=widen_types,
                order="desc",
                limit=10,
                **filters,
            )
            entries = [e for e in entries if e.key not in seen_keys]
            if entries:
                seen_keys.update(e.key for e in entries)
                lines = [_format_entry(e) for e in entries]
                sections.append(f"## {label}\n" + "\n".join(lines))

        # --- Step 3: Truncate to budget ---
        text = "\n\n".join(sections)
        if len(text) > char_budget:
            text = text[:char_budget] + "\n... [truncated]"

        return text

    def __repr__(self) -> str:
        return f"MemoryView(agent_id={self.agent_id!r}, scope={self.scope})"


# ======================================================================
# Helpers
# ======================================================================

def _format_entry(entry: Entry) -> str:
    """Format a single Entry as a human-readable line."""
    tag_str = f" [{', '.join(entry.tags)}]" if entry.tags else ""
    target_str = f" -> {entry.target_id}" if entry.target_id else ""
    return (
        f"[{entry.type.value}] {entry.agent_id}{target_str}{tag_str}: "
        f"{entry.data}"
    )


def _build_scope_levels(scope: dict) -> list[tuple[str, dict]]:
    """Build progressively wider scope filter dicts.

    For an agent at (project=P, session=S, sweep=W, run=R):
      - run level:     project=P, session=S, sweep=W, run=R
      - sweep level:   project=P, session=S, sweep=W
      - session level: project=P, session=S
      - project level: project=P

    Only includes levels where the scope field is not None.
    Skips the narrowest level that matches the agent's own scope
    (those entries are already in "My Entries").
    """
    levels: list[tuple[str, dict]] = []

    p = scope["project"]
    s = scope.get("session")
    w = scope.get("sweep")
    r = scope.get("run")

    # Build from narrow to wide, skipping the agent's own scope level.
    # Agent at run level -> widen to sweep, session, project.
    # Agent at sweep level -> widen to session, project.
    # Agent at session level -> widen to project.
    if r is not None and w is not None and s is not None:
        # Agent is at run level
        levels.append(("Sweep Context", {"project": p, "session": s, "sweep": w}))
        levels.append(("Session Context", {"project": p, "session": s}))
    elif w is not None and s is not None:
        # Agent is at sweep level
        levels.append(("Session Context", {"project": p, "session": s}))
    elif s is not None:
        # Agent is at session level -- nothing between session and project
        pass

    levels.append(("Project Context", {"project": p}))
    return levels
