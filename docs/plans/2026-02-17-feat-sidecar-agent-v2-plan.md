---
title: "feat: Sidecar Agent V2 (skill-driven smart monitoring)"
type: feat
date: 2026-02-17
issue: https://github.com/hao-ai-lab/research-agent/issues/165
---

# Sidecar Agent V2 Design (Pivot)

## Problem
The sidecar had too much hard-coded smart logic (syndrome rules, thresholds, and workload heuristics). That makes behavior brittle, expensive to maintain, and hard to evolve per workload.

## Design Principles
1. **Hard-code only mechanical control flow** (launch, monitor loop, status, metrics post, GPU preflight, alert plumbing).
2. **Move smart behavior into skills/prompts** retrieved at runtime.
3. **Support JIT analysis artifacts** (visualization specs / notes) generated by agent decisions.
4. **Keep the sidecar architecture clean** with explicit boundaries.

## Architecture

### Mechanical Layer (hard-coded)
- tmux pane management and command execution
- run lifecycle state updates
- WandB/metrics delta posting
- `CUDA_VISIBLE_DEVICES` preflight occupancy check
- deterministic fatal metric check (`NaN/Inf` loss)
- alert request/response plumbing

### Smart Layer (skill-driven)
- Sidecar loads skills from `server/prompt_skills/*` at startup.
- Sidecar runs a periodic smart agent session when logs/metrics changed.
- The agent decides:
  - `action`: `alert` or `ignore`
  - `message`, `severity`, `syndrome`, `evidence`
  - optional `jit_tasks` for data analysis artifacts
- Sidecar materializes `jit_tasks` into run-scoped artifacts (`run_dir/analysis/*`), then publishes artifact paths in run monitoring state.

## New Skill Contracts
- `server/prompt_skills/sidecar_smart_monitoring/SKILL.md`
- `server/prompt_skills/sidecar_smart_visualization_jit/SKILL.md`

Skills define smart judgment and JIT visualization/report output format. Sidecar only enforces schema + execution loop.

## User Story
As an experiment owner running diverse workloads, I want sidecar to use reusable skills to reason about logs/metrics and generate on-demand analysis artifacts so monitoring quality improves without shipping new hard-coded rules for every syndrome.

## Acceptance Criteria
- Sidecar smart decisions are driven by loaded skills, not hard-coded syndrome rules.
- Sidecar can emit JIT analysis artifacts (`vega_lite_spec`, `markdown_note`) per run.
- Sidecar still handles mechanical responsibilities reliably (launching, posting metrics, status, GPU preflight).
- Run status includes monitoring notes/tags and artifact references for observability.

## Test Cases

### Automated Unit Tests
1. Mechanical: parse `CUDA_VISIBLE_DEVICES` variants.
2. Mechanical: deterministic non-finite loss alert + dedupe.
3. Mechanical: incremental log tail reading.
4. Smart: load skills from skill root.
5. Smart: parse agent JSON decision with JIT tasks.
6. Smart: materialize JIT visualization/note artifacts.
7. Smart: analysis scheduler only runs when data changes.

### Manual Validation
1. Change skill text in `sidecar_smart_monitoring`; confirm behavior changes without code edits.
2. Trigger smart output with `jit_tasks`; confirm artifacts appear in `run_dir/analysis` and are exposed in monitoring payload.
3. Keep `CUDA_VISIBLE_DEVICES` busy; verify preflight wait + operator decision path still works.

## Rollout Notes
- Start with conservative smart-session cadence.
- Add more skills over time rather than new hard-coded heuristics.
- Keep agent JSON schema stable so frontend/server integration stays predictable.
